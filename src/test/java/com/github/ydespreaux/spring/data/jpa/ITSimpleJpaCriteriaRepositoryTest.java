/* * Copyright (C) 2018 Yoann Despréaux * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation; either version 2 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; see the file COPYING . If not, write to the * Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. * * Please send bugreports with examples or suggestions to yoann.despreaux@believeit.fr */package com.github.ydespreaux.spring.data.jpa;import com.github.ydespreaux.spring.data.jpa.configuration.JpaConfiguration;import com.github.ydespreaux.spring.data.jpa.configuration.entities.Author;import com.github.ydespreaux.spring.data.jpa.configuration.entities.Book;import com.github.ydespreaux.spring.data.jpa.configuration.entities.BookDTO;import com.github.ydespreaux.spring.data.jpa.configuration.repository.AuthorRepository;import com.github.ydespreaux.spring.data.jpa.configuration.repository.BookRepository;import com.github.ydespreaux.spring.data.jpa.query.Criteria;import com.github.ydespreaux.testcontainers.mysql.MySQLContainer;import org.junit.Before;import org.junit.ClassRule;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.domain.Sort;import org.springframework.lang.Nullable;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import java.time.Instant;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.ZoneId;import java.util.Date;import java.util.Optional;import static org.hamcrest.Matchers.is;import static org.junit.Assert.*;/** * @author Yoann Despréaux * @since 0.0.3 */@RunWith(SpringJUnit4ClassRunner.class)@SpringBootTest(classes = JpaConfiguration.class)public class ITSimpleJpaCriteriaRepositoryTest {    @ClassRule    public static final MySQLContainer mySqlContainer = new MySQLContainer()            .withUsername("user")            .withPassword("password");    @Autowired    private BookRepository repository;    @Autowired    private AuthorRepository authorRepository;    private Author nicolasBeuglet = null;    private Author elenaFerrante = null;    private Author harlanCoben = null;    private Book leCri = null;    private Book amieProdigieuse = null;    private Book sansDefense = null;    private Book walkingDead28 = null;    private Book walkingDead29 = null;    @Before    public void onSetUp() {        this.repository.deleteAllInBatch();        this.authorRepository.deleteAllInBatch();        nicolasBeuglet = createAuthorAndSave("Nicolas", "Beuglet");        elenaFerrante = createAuthorAndSave("Elena", "Ferrante");        harlanCoben = createAuthorAndSave("Harlan", "Coben");        leCri = this.createBookAndSave(                "Le cri",                "À quelques kilomètres d'Oslo, l'hôpital psychiatrique de Gaustad dresse sa masse sombre parmi les pins enneigés. Appelée sur place pour un suicide, l'inspectrice Sarah Geringën pressent d'emblée que rien ne concorde. Le patient 488, ainsi surnommé suivant les chiffres cicatrisés qu'il porte sur le front, s'est figé dans la mort, un cri muet aux lèvres – un cri de peur primale. Soumise à un compte à rebours implacable, Sarah va découvrir une vérité vertigineuse sur l'une des questions qui hante chacun d'entre nous : la vie...",                Book.Genre.THRILLER,                "Pocket",                nicolasBeuglet,                8.20,                buildPublication(2018, 1, 11));        amieProdigieuse = this.createBookAndSave(                "L’amie Prodigieuse - Tome 3 : Celle qui fuit et celle qui reste",                "Après L'amie prodigieuse et Le nouveau nom, Celle qui fuit et celle qui reste est la suite de la formidable saga dans laquelle Elena Ferrante raconte cinquante ans d'histoire italienne et d'amitié entre ses deux héroïnes, Elena et Lila. Pour Elena, comme pour l'Italie, une période de grands bouleversements s'ouvre. Nous sommes à la fin des années soixante, les événements de 1968 s'annoncent, les mouvements féministes et protestataires s'organisent, et Elena, diplômée de l'Ecole normale de Pise et entourée d'universitaires,...",                Book.Genre.FICTION,                "Gallimard",                elenaFerrante,                8.30,                buildPublication(2018, 1, 25));        sansDefense = this.createBookAndSave(                "Sans défense",                "Deux enfants kidnappés. Un inconnu qui réapparaît. Après dix ans d'angoisse, le cauchemar ne fait que commencer...",                Book.Genre.THRILLER,                "Belfond",                harlanCoben,                21.90,                buildPublication(2018, 3, 1));        walkingDead28 = this.createBookAndSave("Walking Dead - Tome 28 : Walking Dead",                "La Colline a été dévastée et la communauté qui l'habitait a du fuir les lieux, sous l'impulsion de Maggie. Dwight a rejoint Rick, en lui affirmant que les Chuchoteurs ont été anéantis. Malheureusement, même si Beta - qui a pris la tête des Chuchoteurs - a perdu une bataille, il lance une horde de rôdeurs sur Alexandria. La guerre est peut-être terminée, mais la survie d'Alexandria est en jeu...",                Book.Genre.FANTASTIQUE,                "Delcourt",                null,                14.95,                buildPublication(2017, 10, 14));        walkingDead29 = this.createBookAndSave("Walking Dead - Tome 29 : La Ligne blanche",                "Carl ne parvient pas à admettre la mort d'Andrea. Tandis que Rick fait au mieux, Maggie n'accepte pas sa décision de laisser Negan en liberté et le fait étroitement surveillé. Eugene contacte Stephanie par radio et ils conviennent de se rencontrer. À la suite de ces tragiques événements, Rick envisage d'établir une communauté dans l'Ohio. Une nouvelle ère débute pour les survivants de l'apocalypse...",                Book.Genre.FANTASTIQUE,                "Delcourt",                null,                14.95,                buildPublication(2018, 3, 7));    }    @Test    public void findAllDTOByGenreAndPrice() {        Criteria criteria = new Criteria(Book.BookPropertyPath.GENRE.getPropertyPath()).is(Book.Genre.FANTASTIQUE)                .or(Book.BookPropertyPath.GENRE.getPropertyPath()).is(Book.Genre.FICTION)                .and(Book.BookPropertyPath.PRICE.getPropertyPath()).between(8, 10);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 2), new BookConverter(), "author");        assertEquals(1, result.getTotalElements());        assertEquals(1, result.getNumberOfElements());        checkBook(this.amieProdigieuse, result.getContent().get(0));    }    @Test    public void findAllDTOByTitleWithMultiCriteres() {        Criteria criteria = new Criteria(Book.BookPropertyPath.TITLE.getPropertyPath()).contains("Walking Dead")                .and(Book.BookPropertyPath.DESCRIPTION.getPropertyPath()).contains("La Colline");        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 2), new BookConverter(), "author");        assertEquals(1, result.getTotalElements());        assertEquals(1, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));    }    @Test    public void findAllDTOByTitleWithMultiCriteres_grouped() {        Criteria criteria = new Criteria(Book.BookPropertyPath.TITLE.getPropertyPath()).contains("Walking Dead")                .or(Book.BookPropertyPath.DESCRIPTION.getPropertyPath()).contains("La Colline");        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 2), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));        checkBook(this.walkingDead29, result.getContent().get(1));    }    @Test    public void findAllDTOByTitleWithEq() {        Criteria criteria = new Criteria(Book.BookPropertyPath.TITLE.getPropertyPath()).is("Sans défense");        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 2), new BookConverter(), "author");        assertEquals(1, result.getTotalElements());        assertEquals(1, result.getNumberOfElements());        checkBook(this.sansDefense, result.getContent().get(0));    }    @Test    public void findAllDTOByGenreWithEq() {        Criteria criteria = new Criteria("genre").is(Book.Genre.THRILLER);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 2), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.leCri, result.getContent().get(0));        checkBook(this.sansDefense, result.getContent().get(1));    }    @Test    public void findAllDTOByGenreWithNotEq() {        Criteria criteria = new Criteria("genre").isNot(Book.Genre.THRILLER);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 2), new BookConverter(), "author");        assertEquals(3, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.amieProdigieuse, result.getContent().get(0));        checkBook(this.walkingDead28, result.getContent().get(1));        Page<BookDTO> result1 = this.repository.findAll(criteria, createPageable(1, 2), new BookConverter(), "author");        assertEquals(3, result1.getTotalElements());        assertEquals(1, result1.getNumberOfElements());        checkBook(this.walkingDead29, result1.getContent().get(0));    }    @Test    public void findAllDTOByGenreWithIn() {        Criteria criteria = new Criteria("genre").in(Book.Genre.THRILLER, Book.Genre.FICTION);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(3, result.getTotalElements());        assertEquals(3, result.getNumberOfElements());        checkBook(this.leCri, result.getContent().get(0));        checkBook(this.amieProdigieuse, result.getContent().get(1));        checkBook(this.sansDefense, result.getContent().get(2));    }    @Test    public void findAllDTOByGenreWithNotIn() {        Criteria criteria = new Criteria("genre").notIn(Book.Genre.THRILLER, Book.Genre.FICTION);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));        checkBook(this.walkingDead29, result.getContent().get(1));    }    @Test    public void findAllDTOByAuthorWithNull() {        Criteria criteria = new Criteria("author").isNull();        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 2), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));        checkBook(this.walkingDead29, result.getContent().get(1));    }    @Test    public void findAllDTOByAuthorWithNotNull() {        Criteria criteria = new Criteria("author").isNotNull();        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(3, result.getTotalElements());        assertEquals(3, result.getNumberOfElements());        checkBook(this.leCri, result.getContent().get(0));        checkBook(this.amieProdigieuse, result.getContent().get(1));        checkBook(this.sansDefense, result.getContent().get(2));    }    @Test    public void findAllDTOByPriceWithBetween() {        Criteria criteria = new Criteria(Book.BookPropertyPath.PRICE.getPropertyPath()).between(10.0, 20.0);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));        checkBook(this.walkingDead29, result.getContent().get(1));    }    @Test    public void findAllDTOByPriceWithGreater() {        Criteria criteria = new Criteria(Book.BookPropertyPath.PRICE.getPropertyPath()).greaterThan(21.90);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(0, result.getTotalElements());        assertEquals(0, result.getNumberOfElements());    }    @Test    public void findAllDTOByPriceWithGreaterOrEquals() {        Criteria criteria = new Criteria(Book.BookPropertyPath.PRICE.getPropertyPath()).greaterThanEqual(21.90);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(1, result.getTotalElements());        assertEquals(1, result.getNumberOfElements());        checkBook(this.sansDefense, result.getContent().get(0));    }    @Test    public void findAllDTOByPriceWithLess() {        Criteria criteria = new Criteria(Book.BookPropertyPath.PRICE.getPropertyPath()).lessThan(8.30);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(1, result.getTotalElements());        assertEquals(1, result.getNumberOfElements());        checkBook(this.leCri, result.getContent().get(0));    }    @Test    public void findAllDTOByPriceWithLessOrEquals() {        Criteria criteria = new Criteria(Book.BookPropertyPath.PRICE.getPropertyPath()).lessThanEqual(8.30);        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.leCri, result.getContent().get(0));        checkBook(this.amieProdigieuse, result.getContent().get(1));    }    @Test    public void findAllDTOByDescriptionWithContains() {        Criteria criteria = new Criteria(Book.BookPropertyPath.DESCRIPTION.getPropertyPath()).contains("Rick");        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));        checkBook(this.walkingDead29, result.getContent().get(1));    }    @Test    public void findAllDTOByTitleWithStartWith() {        Criteria criteria = new Criteria(Book.BookPropertyPath.TITLE.getPropertyPath()).startsWith("Walking");        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));        checkBook(this.walkingDead29, result.getContent().get(1));    }    @Test    public void findAllByTitleWithStartWith() {        Criteria criteria = new Criteria(Book.BookPropertyPath.TITLE.getPropertyPath()).startsWith("Walking");        Page<Book> result = this.repository.findAll(criteria, createPageable(0, 5));        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.walkingDead28, result.getContent().get(0));        checkBook(this.walkingDead29, result.getContent().get(1));    }    @Test    public void searchByTitleWithEndWith() {        Criteria criteria = new Criteria(Book.BookPropertyPath.TITLE.getPropertyPath()).endsWith("reste");        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(1, result.getTotalElements());        assertEquals(1, result.getNumberOfElements());        checkBook(this.amieProdigieuse, result.getContent().get(0));    }    @Test    public void searchByPublicationWithBetween() {        Criteria criteria = new Criteria(Book.BookPropertyPath.PUBLICATION.getPropertyPath()).between(buildPublication(2018, 1, 1), buildPublication(2018, 2, 1));        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(2, result.getTotalElements());        assertEquals(2, result.getNumberOfElements());        checkBook(this.leCri, result.getContent().get(0));        checkBook(this.amieProdigieuse, result.getContent().get(1));    }    @Test    public void searchByAuthor() {        Criteria criteria = new Criteria(Book.BookPropertyPath.AUTHOR_LASTNAME.getPropertyPath()).contains("coben");        Page<BookDTO> result = this.repository.findAll(criteria, createPageable(0, 5), new BookConverter(), "author");        assertEquals(1, result.getTotalElements());        assertEquals(1, result.getNumberOfElements());        checkBook(this.sansDefense, result.getContent().get(0));    }    @Test    public void findBookDTOById() {        Optional<BookDTO> result = this.repository.findById(this.amieProdigieuse.getId(), new BookConverter(), "author");        assertThat(result.isPresent(), is(true));        checkBook(this.amieProdigieuse, result.get());    }    /**     * @param firstName     * @param lastName     * @return     */    private Author createAuthor(String firstName, String lastName) {        Author author = new Author();        author.setFirstName(firstName);        author.setLastName(lastName);        return author;    }    /**     * @param firstName     * @param lastName     * @return     */    private Author createAuthorAndSave(String firstName, String lastName) {        return this.authorRepository.save(createAuthor(firstName, lastName));    }    /**     * @param title     * @param description     * @param genre     * @param editor     * @param author     * @param price     * @param publication     * @return     */    private Book createBook(String title, String description, Book.Genre genre, String editor, Author author, Double price, LocalDate publication) {        return Book.builder()                .title(title)                .description(description)                .genre(genre)                .editor(editor)                .author(author)                .price(price)                .publication(publication)                .build();    }    /**     * @param title     * @param description     * @param genre     * @param editor     * @param author     * @param price     * @param publication     * @return     */    private Book createBookAndSave(String title, String description, Book.Genre genre, String editor, Author author, Double price, LocalDate publication) {        return this.repository.save(createBook(title, description, genre, editor, author, price, publication));    }    /**     * @param reference     * @param other     */    private void checkBook(Book reference, BookDTO other) {        assertEquals(reference.getTitle(), other.getTitle());        assertEquals(reference.getDescription(), other.getDescription());        if (reference.getAuthor() == null) {            assertNull(other.getAuthor());        } else {            assertEquals(reference.getAuthor().getFirstName() + " " + reference.getAuthor().getLastName(), other.getAuthor());        }        assertEquals(reference.getEditor(), other.getEditor());        assertEquals(reference.getPrice(), other.getPrice());        // Prose en compte du fuseau horaire        LocalDate referenceLocalDate = LocalDateTime.ofInstant(                Instant.ofEpochMilli(Date.from(reference.getPublication().atStartOfDay(ZoneId.systemDefault()).toInstant()).getTime()),                ZoneId.systemDefault()).toLocalDate();        assertEquals(referenceLocalDate, other.getPublication());        assertEquals(reference.getGenre(), other.getGenre());        assertEquals(reference.getId(), other.getId());    }    private void checkBook(Book reference, Book other) {        assertEquals(reference.getTitle(), other.getTitle());        assertEquals(reference.getDescription(), other.getDescription());        assertEquals(reference.getEditor(), other.getEditor());        assertEquals(reference.getPrice(), other.getPrice());        // Prose en compte du fuseau horaire        LocalDate referenceLocalDate = LocalDateTime.ofInstant(                Instant.ofEpochMilli(Date.from(reference.getPublication().atStartOfDay(ZoneId.systemDefault()).toInstant()).getTime()),                ZoneId.systemDefault()).toLocalDate();        assertEquals(referenceLocalDate, other.getPublication());        assertEquals(reference.getGenre(), other.getGenre());        assertEquals(reference.getId(), other.getId());    }    /**     * @param year     * @param month     * @param day     * @return     */    private LocalDate buildPublication(int year, int month, int day) {        return LocalDate.of(year, month, day);    }    /**     * @return     */    private Pageable createPageable(int page, int size) {        return PageRequest.of(page, size, Sort.by(Sort.Direction.ASC, "title"));    }    /**     *     */    private static class BookConverter implements ModelConverter<BookDTO, Book> {        /**         * @param source         * @return         */        @Override        public BookDTO convertToDTO(Book source) {            return BookDTO.builder()                    .title(source.getTitle())                    .description(source.getDescription())                    .author(source.getAuthor() == null ? null : source.getAuthor().getFirstName() + " " + source.getAuthor().getLastName())                    .editor(source.getEditor())                    .genre(source.getGenre())                    .id(source.getId())                    .price(source.getPrice())                    .publication(source.getPublication())                    .build();        }        @Nullable        @Override        public Book convert(BookDTO bookDTO) {            throw new UnsupportedOperationException();        }    }}